# Pipeline in C by @abambi

# main:

- проверяем количество аргументов через **argc**. Если их не 5 (т.е. адрес + 4 наших аргумента), то сообщаем об этой ошибке и выходим.

Если все ок, продолжаем работать:

- заводим **fd**-шники и открываем 1й и 4й аргумент (файлы, `open()`) через присланный нам `argv`. Проверяем, нет ли ошибки (-1) при открытии файлов.
- заводим `pipe()` - это временный буфер, через который будут сообщаться оба процесса, когда мы их запустим (а они оба существуют в своей отдельной области памяти и выполняются независимо)
- Проверяем на ошибку при запуске `pipe` (там тоже может быть -1)
- Потом уже заводим `fork()`. Теперь у нас 2 процесса, в каждый из них скопированы все переменные и их значения, которые были до появления в коде `fork()`.
- `fork` тоже проверить на ошибку (-1).

> `fork()` надо не просто запустить, а проверить возвращаемое значение. Если 0 - то это дочерний процесс, а если любое другое число, кроме  (-1: ошибки), то это родительский процесс. Теперь можно уже сделать условие: если значение 0, то запустить функцию дочерний_процесс. А если другое (после предварительной проверки на -1), то запустить функцию родительский_процесс. Так как **fd**-шники скопировались (из-за `fork()`), то надо лишние закрыть, которые не используются. Если на этом не заострять внимание, то в целом дальше вот что: надо сделать так, чтобы родительский процесс подождал, пока отработает дочерний. Так принято, так как будут проблемы с освобождением памяти  (вроде как) если родительский отработает и закроется (и дочерний будет "подвешен" без родителя).

Потом нужно сделать так, чтобы все что читалось, читалось не из консоли (**fd 0**) и записывалось не в консоль (**fd 1**), а в файл и из файла. Потому что если мы свои предполагаемые команды запустим на выполнение, случится должно именно это

Для этого используется функция `dup2`.

Когда мы писали функцию `pipe(массив_на_2_fd)`, то в этом массиве `fd[0]` отвечает за чтение, а `fd[1]` - за запись в буферный файл.

Остается соединить 2 файла из аргументов и эту трубку соединяющую 2 процесса:

Например,

`dup2(fd1, 0);`

`dup2(pipe_fd2, 1);`

где `fd1` - это открытый файл (аргумент 1 из **main**)

а `pipe_fd2` - это фд трубки для чтения внутрь файла-буфера (`fd[1]` - выше который)

А также

`dup2(pipe_fd1, 0);`

`dup2(fd2, 1);`

Тут конец трубки на чтение из буферного файла (ассоциированный с 0, то есть в обычном случае это было бы чтение из консоли).

И теперь **fd2** - это файл-аргумент 4 из **main**.

Только первое делается в дочернем процессе, а второе - в родительском. Впрочем это я еще не оттестировала.

Но все по логике нужно чтобы соединить файл 1 и трубку на запись в буферный файл. И трубку на чтение из буферного файла и файл 4 на запись в него вывода второй команды

Теперь все соединилось между собой, но нужно как-то выполнить команды, для этого используют команду `execve`, она сама все выполняет, без нашего участия. Но туда надо подать аргументы

То есть сначала соединяем c помощью `dup2` все концы трубки и файлы, а потом вызываем функцию `execve`, она выполняет все команды и мы закрываем **fd**-шники и работа выполнена

Но есть загвоздка с `execve`, туда надо подать команду (которая придет 2м/3м аргументом в **main**). В `execve` это - второй аргумент. Но 1-й аргумент в `execve` - это путь к команде, иначе она не выполнится, компилятор не знает откуда ее взять. А достаточно простое - это 3-й аргумент - нужно послать переменную окружения (которая что-то типа глобальной переменной, ее свойства я не разбирала подробно). Ее достаточно объявить в функции и добавить библиотеку ммм... ***#include <stdlib.h>*** ? что ли. Какая-то еще библиотека тоже подходит. Объявляется переменная так: ***extern char    **environ***;

И после этого она сама как-то работает. Ее просто нужно вписать 3м аргументом в функцию `execve`

И остается последний вопрос с путем к переменной для функции `execve`.

В `execve` 2м аргументом нужно подать не просто считанный 2 или 3й аргумент (то есть для дочернего процесса посылаем 2-й аргумент, а для родительского - 3-й. Отделяем, какой процесс с помощью того значения, которое вернула функция `fork()`. То есть 0 - это точно дочерний процесс). А подать нужно массив строчек. Во всех вариантах, что я видела, это делается с помощью нашей либовской функции ***strsplit***. Получается массив строк, и это подается в `execve`

Теперь насчет пути. Надо проверить, если в **main** пришла команда с путем (то есть переменная начинается с такого '/' или '../' или './' - до других вариантов я не додумалась). То мы просто отправляем полученный массив с индексом [0] . Как бы сначала получаем массив, и в `execve` попадает *(массив[0],  массив(просто массив без индекса,  environ)*;

Проверяем, что вернула функция `execve`, если -1 - то такой команды не существует, там разные варианты подписи, типа попробуйте не указывать путь, и на выход с ошибкой.

А второй вариант, если во 2й/3й аргумент **main** не пришла команда с написанным путем, то его надо найти. Ищем мы опять через переменную окружения environ.  В этой переменной ищем строку "PATH=" если нашли, то после этого слова вызываем ***strsplit***, и все пути себе в массив сохраняем с разделителем `':'`

Так как 1-й аргумент в `execve` - это путь вместе с командой, то обычно делают цикл:

перебираем массив с путями,  к каждому пути ***стрджойним*** `'/'` и команду (можно использовать, например `ft_strjoin(ft_strjoin(path[i], "/"), command_x)`;

И каждый полученный полный путь с командой запускаем в функцию `execve` и смотрим, какой return вернула функцию `execve`.

Если мы дошли до конца массива  с путями и ни разу не вернулось что-то отличное от -1 (вот здесь можно `break ;` сделать), то как и раньше - на выход с ошибкой, типа команды не существует.А если вернулось что-то отличное от -1, то `execve` отработала, и дальше все уже автоматически отрабатывает - все записывается в/из нужных файлов/концов трубки. И само завершается. Остается только открыть созданный файл (это имя 4-го аргумента) и посмотреть, что получилось. А 1-й файл (1-й аргумент) уже должен существовать с каким-то текстом для обработки.